
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>boiecox_ed_cvip</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-06-26"><meta name="DC.source" content="boiecox_ed_cvip.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">create a gaussian filter mask</a></li><li><a href="#4">convovle gaussian filter with image</a></li><li><a href="#5">Find determinants in four different directions</a></li><li><a href="#6">Apply Ordinary Thresholding</a></li><li><a href="#7">Apply Hysteresis Thresholding</a></li><li><a href="#8">Apply thinning</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [ out_img, TH_img, hTH_img ] = boiecox_ed_cvip( input_img, va, hys_th, thin, high_th, low_th )
</pre><pre class="codeinput"><span class="comment">% BOIECOX_ED_CVIP - Boiecox edge detection of an input image.</span>
<span class="comment">%</span>
<span class="comment">% Syntax :</span>
<span class="comment">% --------</span>
<span class="comment">% [ out_img ] = boiecox_ed_cvip( input_img, va, hys_th, thin, high_th, low_th )</span>
<span class="comment">%</span>
<span class="comment">% Description :</span>
<span class="comment">% -------------</span>
<span class="comment">% The function performs the Boiecox edge detection on an image. The Boiecox</span>
<span class="comment">% edge detection algorithm was developed by R.A. Boie and I.J. Cox in 1987.</span>
<span class="comment">% The algorithm is similar to that of Canny's edge detection algorithm. It</span>
<span class="comment">% is a multistep algorithm where the image is first blurred with a Gaussian</span>
<span class="comment">% kernel and then a matched filter is applied to the image. The matched</span>
<span class="comment">% filter is used to find and detect the edges in an image and localize them</span>
<span class="comment">% to subpixel accuracy. The image is then operated by a wiener filter which</span>
<span class="comment">% boosts the signal amplitude and reduces the noise that may be present in</span>
<span class="comment">% the image. Matched filter is applied in an edge normal direction whereas</span>
<span class="comment">% wiener filter is applied along the edge contour.</span>
<span class="comment">%</span>
<span class="comment">% Input Parameters Include:</span>
<span class="comment">% ------------------------</span>
<span class="comment">%</span>
<span class="comment">%             'input_img'     The Input Image. Can be Single band or Multi band.</span>
<span class="comment">%</span>
<span class="comment">%                    'va'     Variance of the Gaussian blur Kernel.</span>
<span class="comment">%                             It decides the size of the Gaussian kernel used.</span>
<span class="comment">%                             Ranges from 0.5 to 10.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%                 'hys_th'    Hysteresis Threshold. It is either 0 or 1.</span>
<span class="comment">%                             '1' indicates Hysteresis thresholding.</span>
<span class="comment">%                             '0' indicates no hysteresis thresholding.</span>
<span class="comment">%                             Default value : 1.</span>
<span class="comment">%</span>
<span class="comment">%                   'thin'    Morphological thinning of output. It is either 0 or 1.</span>
<span class="comment">%                             '1' indicates thinning operation.</span>
<span class="comment">%                             '0' indicates no thinning operation.</span>
<span class="comment">%                             Default value : 1.</span>
<span class="comment">%</span>
<span class="comment">%               'high_th'     High Threshold value used in Hysteresis Thresholding.</span>
<span class="comment">%                             Ranges from 1 to 10. When Hysteresis threshold is not selected,</span>
<span class="comment">%                             used as a threshold value for ordinary thresholding.</span>
<span class="comment">%</span>
<span class="comment">%                 'low_th'    Low Threshold value used in hysteresis thresholding.</span>
<span class="comment">%                             Ranges from 0 to 1.</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">% -------</span>
<span class="comment">%                          input_img = imread('car.bmp');</span>
<span class="comment">%                          va = 1;</span>
<span class="comment">%                          hys_th = 1;</span>
<span class="comment">%                          thin = 1;</span>
<span class="comment">%                          high_th = 1;</span>
<span class="comment">%                          low_th = 0.2;</span>
<span class="comment">%                          output = boiecox_ed_cvip(input_img,va,hys_th,thin,high_th,low_th);</span>
<span class="comment">%                          figure; imshow(output);</span>
<span class="comment">% Reference</span>
<span class="comment">% ----------</span>
<span class="comment">%  1. R.A. Boie, I.J. Cox, Two Dimensional Optimum Recognition Using Matched Filters and Wiener</span>
<span class="comment">%  Filters for Machine Vision, IEEE First International Conference on Computer Vision,</span>
<span class="comment">%  IEEE, pp.450-456, 1987.</span>

<span class="comment">% =========================================================================</span>
<span class="comment">%</span>
<span class="comment">%           Author:                 Akhila Karlapalem</span>
<span class="comment">%           Initial coding date:    11/22/2017</span>
<span class="comment">%           Updated by:             Julian Rene Cuellar Buritica</span>
<span class="comment">%           Latest update date:     01/20/2019</span>
<span class="comment">%           Credit:                 Scott Umbaugh</span>
<span class="comment">%                                   CVIP Lab, SIUE</span>
<span class="comment">%           Copyright (C) 2016 Scott Umbaugh and SIUE</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% =========================================================================</span>

<span class="comment">% Revision History</span>
<span class="comment">%</span>
 <span class="comment">% Revision 1.2  01/20/2019  15:41:56  jucuell</span>
 <span class="comment">% intermadite variables for Thresholding image output anf hysteresis TH.</span>
<span class="comment">%</span>
 <span class="comment">% Revision 1.1  11/22/2017  15:21:14  akarlap</span>
 <span class="comment">% function creation, coding and initial testing</span>
<span class="comment">%</span>

<span class="keyword">global</span> EDGEX EDGEY EDGE45 EDGE135 diag_scale m n d

input_img = remap_cvip(input_img,[0 255]);
[m,n,d] = size(input_img);
diag_scale = 1.414;
EDGEX = 252;
EDGEY = 253;
EDGE45 = 254;
EDGE135 = 255;

<span class="keyword">if</span> isempty(hys_th)
    hys_th = 1;
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(thin)
    thin = 1;
<span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in boiecox_ed_cvip (line 88)
input_img = remap_cvip(input_img,[0 255]);
</pre><h2 id="3">create a gaussian filter mask</h2><pre class="codeinput">hlf = int8(sqrt(-log(0.05)*2*va*va));
sze = 2*hlf + 1;
sze = double(sze);

gau = zeros(sze,sze);


<span class="keyword">for</span> i = 1:sze
    <span class="keyword">for</span> j = 1:sze
        r = double(i);
        c = double(j);
        u1 = r - (sze + 1)/2;
        u2 = c - (sze + 1)/2;
        gau(i,j) = gaussboie(double(u1), va)* gaussboie(double(u2),va);
    <span class="keyword">end</span>
<span class="keyword">end</span>
gau = double(gau);


temp_img = input_img;
</pre><h2 id="4">convovle gaussian filter with image</h2><pre class="codeinput">img_x = convn(temp_img,gau,<span class="string">'same'</span>);
</pre><h2 id="5">Find determinants in four different directions</h2><pre class="codeinput">imgdetx = img_detx(img_x);
imgdety = img_dety(img_x);
imgdet135 = img_det135(img_x);
imgdet45 = img_det45(img_x);

TH_img = zeros(m,n,d);

sx = abs(imgdetx(:,:,:));
sy = abs(imgdety(:,:,:));
s45 = int8(double(abs(imgdet45(:,:,:))./diag_scale));
s135 = int8(double(abs(imgdet135(:,:,:))./diag_scale));
</pre><h2 id="6">Apply Ordinary Thresholding</h2><pre class="codeinput">    threshold = image_threshold(imgdetx(:,:,:));

        thresholdValue = high_th*threshold;

    <span class="keyword">for</span> r = 1:m
        <span class="keyword">for</span> c = 1:n

            big = sx(r,c,:);
            orient_flag = EDGEX;

            <span class="keyword">if</span> (sy(r,c,:) &gt; big)
                big = sy(r,c,:);
                orient_flag = EDGEY;
            <span class="keyword">end</span>
            <span class="keyword">if</span> (s45(r,c,:) &gt; big)
                big = s45(r,c,:);
                orient_flag = EDGE45;
            <span class="keyword">end</span>
            <span class="keyword">if</span> (s135(r,c,:) &gt; big)
                big = s135(r,c,:);
                orient_flag = EDGE135;
            <span class="keyword">end</span>

           <span class="keyword">for</span> b = 1:d
               <span class="keyword">if</span> (big(b) &gt; thresholdValue(b))
                <span class="keyword">switch</span> orient_flag
                    <span class="keyword">case</span> EDGEX
                        TH_img(r,c,b) = image_zc_x(r,c,imgdetx,b);

                    <span class="keyword">case</span> EDGEY
                        TH_img(r,c,b) = image_zc_y(r,c,imgdety,b);

                    <span class="keyword">case</span> EDGE45
                        TH_img(r,c,b) = image_zc_45(r,c,imgdet45,b);

                    <span class="keyword">case</span> EDGE135
                        TH_img(r,c,b) = image_zc_135(r,c,imgdet135,b);
                <span class="keyword">end</span>
               <span class="keyword">end</span>
           <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    out_img = TH_img;
</pre><h2 id="7">Apply Hysteresis Thresholding</h2><pre class="codeinput">hTH_img = 0;
<span class="keyword">if</span> isequal(hys_th,1)
    low_threshold = double(thresholdValue.*low_th);
    hTH_img = image_hysteresis(imgdetx,imgdety,imgdet45,imgdet135,out_img,low_threshold);
    out_img = hTH_img;
<span class="keyword">end</span>
</pre><h2 id="8">Apply thinning</h2><pre class="codeinput"><span class="keyword">if</span> isequal(thin,1)
    out_img = image_thin(out_img);
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>


<span class="keyword">function</span> [ z ] = gaussboie( x,va )

x = double(x);
<span class="keyword">if</span> isequal(va,0)
    z = double(zero(size(x)));
    <span class="keyword">return</span>;
<span class="keyword">end</span>
z1 = (-x.*x)/(2*va*va);
z2 = (va*sqrt(2*pi));
z = double(exp(double(z1))/z2);
<span class="keyword">end</span>

<span class="keyword">function</span> [imgdetx] = img_detx(img_x)
<span class="keyword">global</span> m n d
imgdetx = zeros(m,n,d);

image2 = img_x;


<span class="comment">% Middle Columns</span>
j = 3:n-1;

        imgdetx(:,j,:) = image2(:,j+1,:) - image2(:,j-1,:);

<span class="keyword">end</span>

<span class="keyword">function</span> [imgdety] = img_dety(img_x)
<span class="keyword">global</span> m n d

imgdety = zeros(m,n,d);

image2 = img_x;

<span class="comment">% Middle Rows</span>

i = 3:m-1;

        imgdety(i,:,:) = image2(i+1,:,:) - image2(i-1,:,:);


<span class="keyword">end</span>

<span class="keyword">function</span> [imgdet135] = img_det135(img_x)
<span class="keyword">global</span> m n d
imgdet135 = zeros(m,n,d);

image2 = img_x;

j = 3:n-1;



<span class="comment">% Diagonal</span>
<span class="keyword">for</span> i = 3:m-1

        imgdet135(i,j,:) = image2(i+1,j+1,:) - image2(i-1,j-1,:);

<span class="keyword">end</span>



i = 3:m-1;

<span class="comment">% Right Column</span>

    imgdet135(i,n,:) = image2(i+1,n,:) - image2(i-1,n-1,:);


<span class="comment">% Bottom Row Without Corner Pixels</span>

    j = 3:n-1;
    imgdet135(m,j,:) = image2(m,j+1,:) - image2(m-1,j-1,:);


<span class="comment">% Top Left Corner</span>
imgdet135(1,1,:) = image2(2,2,:) - image2(1,1,:);

<span class="comment">% Bottom Left Corner</span>
imgdet135(m,1,:) = image2(m,2,:) - image2(m-1,1,:);

<span class="comment">% Bottom Right Corner</span>
imgdet135(m,n,:) = image2(m,n,:) - image2(m-1,n-1,:);

<span class="comment">% Top Right Corner</span>
imgdet135(1,n,:) = image2(2,n,:) - image2(1,n-1,:);

imgdet135(:,:,:) = imgdet135;


<span class="keyword">end</span>

<span class="keyword">function</span> [imgdet45] = img_det45(img_x)
<span class="keyword">global</span> m n d
imgdet45 = zeros(m,n,d);

image2 = img_x;
    j = 3:n-1;
<span class="comment">% Diagonal</span>
<span class="keyword">for</span> i = 3:m-1

        imgdet45(i,j,:) = image2(i+1,j-1,:) - image2(i-1,j+1,:);

<span class="keyword">end</span>


    i = 3:m-1;

<span class="comment">% Right Column</span>

    imgdet45(i,n,:) = image2(i+1,n-1,:) - image2(i-1,n,:);


<span class="comment">% Bottom Row without Corner Pixels</span>

    j = 3:n-1;
    imgdet45(m,j,:) = image2(m,j-1,:) - image2(m-1,j+1,:);


<span class="comment">% Top Left Corner</span>
imgdet45(1,1,:) = image2(2,1,:) - image2(1,2,:);

<span class="comment">% Bottom Left Corner</span>
imgdet45(m,1,:) = image2(m,1,:) - image2(m-1,2,:);

<span class="comment">% Bottom Right Corner</span>
imgdet45(m,n,:) = image2(m,n-1,:) - image2(m-1,n,:);

<span class="comment">% Top Right Corner</span>
imgdet45(1,n,:) = image2(2,n-1,:) - image2(1,n,:);

imgdet45(:,:,:) = imgdet45;


<span class="keyword">end</span>

<span class="keyword">function</span> [threshold] = image_threshold(imagedetx)
<span class="keyword">global</span> m n d
threshold = zeros(1,1,d);
<span class="keyword">for</span> b = 1:d
a = imagedetx(:,:,b);
s = sum(a(:));
mad2 = s/numel(imagedetx);
mad1 = abs(imagedetx(:,:,b) - mad2);
mad = sum(mad1(:));
threshold(:,:,b) = int8(double((3*mad/m/n))/0.8);
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [outImage] = image_thin(out_img)
<span class="keyword">global</span> m n d
<span class="keyword">for</span> b = 1:d
    <span class="keyword">for</span> j = 2:n-1
        <span class="keyword">for</span> i = 2:m-1
            b01 = out_img(i-1,j,b) &gt; 0;
            b12 = out_img(i,j+1,b) &gt; 0;
            b21 = out_img(i+1,j,b) &gt; 0;
            b10 = out_img(i,j-1,b) &gt; 0;

            <span class="keyword">if</span> ((b01 + b12 + b21 + b10) &gt; 1)
                b00 = out_img(i-1,j-1,b) &gt; 0;
                b02 = out_img(i-1,j+1,b) &gt; 0;
                b20 = out_img(i+1,j-1,b) &gt; 0;
                b22 = out_img(i+1,j+1,b) &gt; 0;

                p1 = b00|b01;
                p2 = b02|b12;
                p3 = b22|b21;
                p4 = b20|b10;

                nlinks(1) = b01 &amp; p2;
                nlinks(2) = b12 &amp; p3;
                nlinks(3) = b21 &amp; p4;
                nlinks(4) = b10 &amp; p1;

                nlinks = sum(nlinks(:));

                npieces = p1 + p2 + p3 + p4;

                <span class="keyword">if</span> ((npieces - nlinks) &lt; 2)
                    out_img(i,j,b) = 0;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

outImage = out_img;
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_zc_x(r,c,imgdetx,b)
<span class="keyword">global</span> EDGEX
a1 = image_locx(c,r,imgdetx,b);
a2 = image_locx(c+1,r,imgdetx,b);

    <span class="keyword">if</span> ~isequal((a1 &gt; 0),a2 &gt; 0)
        out = EDGEX;
    <span class="keyword">else</span>
        out = 0;
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [out] = image_zc_y(r,c,imgdety,b)
<span class="keyword">global</span> EDGEY
a1 = image_locy(c,r+1,imgdety,b);
a2 = image_locy(c,r,imgdety,b);

    <span class="keyword">if</span> ~isequal(a1 &gt; 0,a2 &gt; 0)
        out = EDGEY;
    <span class="keyword">else</span>
        out = 0;
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [out] = image_zc_45(r,c,imgdet45,b)
<span class="keyword">global</span> EDGE45
a1 = image_loc45(c-1,r+1,imgdet45,b);
a2 = image_loc45(c,r,imgdet45,b);


<span class="keyword">if</span> ~isequal(a1 &gt; 0,a2 &gt; 0)
    out = EDGE45;
<span class="keyword">else</span>
    out = 0;
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_zc_135(r,c,imgdet135,b)
<span class="keyword">global</span> EDGE135
a1 = image_loc135(c+1,r+1,imgdet135,b);
a2 = image_loc135(c,r,imgdet135,b);

<span class="keyword">if</span> ~isequal(a1&gt; 0,a2 &gt; 0)
    out = EDGE135;
<span class="keyword">else</span>
    out = 0;
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_locx(c,r,imgdetx,b)
<span class="keyword">global</span> m n


<span class="keyword">if</span> (r &lt; 2) || (r &gt; m - 2) || (c &lt; 2) || (c &gt; n-1)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdetx(r,c,b) - imgdetx(r,c-1,b);

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_locy(c,r,imgdety,b)
<span class="keyword">global</span> m n


<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-1) || (c &lt; 2) || (c &gt; n-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdety(r,c,b) - imgdety(r-1,c,b);
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_loc45(c,r,imgdet45,b)
<span class="keyword">global</span> m n

<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-2) || (c &lt; 2) || (c &gt; n-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdet45(r,c,b) - imgdet45(r-1,c+1,b);

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_loc135(c,r,imgdet135,b)
<span class="keyword">global</span> m n

<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-2) || (c &lt; 2) || (c &gt; n-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdet135(r,c,b) - imgdet135(r-1,c-1,b);
<span class="keyword">end</span>


<span class="keyword">function</span> [out_img] = image_hysteresis(imgdetx,imgdety,imgdet45,imgdet135,out_img,low_threshold)

<span class="keyword">global</span> tempHyst m n d
tempHyst = zeros(m,n,d);
tempHyst(2:m,2:n,1) = out_img(2:m,2:n,1);
<span class="keyword">if</span> (d &gt; 1)
    <span class="keyword">for</span> f = 2:d
    tempHyst(2:m,2:n,f) = out_img(2:m,2:n,f);
    <span class="keyword">end</span>
<span class="keyword">end</span>

[row,col] = find(tempHyst);
<span class="keyword">for</span> i = 1:length(row)
<span class="keyword">if</span> (col(i) &lt;= n )
    b = 1;
<span class="keyword">elseif</span> (col(i)&gt; n) &amp;&amp; (col(i) &lt;= n*2)
    b = 2;
<span class="keyword">else</span>
    b = 3;
<span class="keyword">end</span>
    image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,col(i),row(i),low_threshold(b));
    image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,col(i),row(i),low_threshold(b));

<span class="keyword">end</span>
out_img = tempHyst;
<span class="keyword">end</span>

<span class="keyword">function</span> [] = image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

<span class="keyword">global</span> tempHyst EDGEX EDGEY EDGE45 EDGE135  m n d
choice = tempHyst(i,j);
<span class="keyword">switch</span> choice
    <span class="keyword">case</span> EDGEY
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+2,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+2,low_threshold);
        <span class="keyword">if</span> ~(Fout11) &amp;&amp; (Fout21)
            <span class="keyword">if</span> ((i+1 &lt; m+1 ) &amp;&amp; (tempHyst(i-1,j+1) == 0))
                tempHyst(i,j+1) = 5;
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Fout31) || (Fout41)) &amp;&amp; ((Fout51) || (Fout61))
            <span class="keyword">if</span> ((i+1 &lt; m+1 ) &amp;&amp; (tempHyst(i-1,j+1) == 0))

                tempHyst(i,j+1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> EDGE135
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+1,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+2,low_threshold);
        <span class="keyword">if</span> ~(Fout11) &amp;&amp; (Fout21)
            <span class="keyword">if</span> ((j-1) &gt;= 1 ) &amp;&amp; (i+1 &lt; m+1 ) &amp;&amp; (tempHyst(i-1,j+1) == 0)
                tempHyst(i-1,j+1) = 5;
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Fout31) || (Fout41)) &amp;&amp; ((Fout51) || (Fout61))
            <span class="keyword">if</span> ((j-1) &gt;= 1 ) &amp;&amp; (i+1 &lt; m+1 ) &amp;&amp; (tempHyst(i-1,j+1) == 0)

                tempHyst(i-1,j+1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> EDGEX
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-1,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+1,low_threshold);
        <span class="keyword">if</span> ~(Fout11) &amp;&amp; (Fout21)
            <span class="keyword">if</span> ((j-1 &gt;= 1) &amp;&amp; (tempHyst(i-1,j) == 0))

                tempHyst(i-1,j) = 5;

            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Fout31) || (Fout41)) &amp;&amp; ((Fout51) || (Fout61))
            <span class="keyword">if</span> ((j-1 &gt;= 1) &amp;&amp; (tempHyst(i-1,j) == 0))
                tempHyst(i-1,j) = 5;

            <span class="keyword">end</span>
        <span class="keyword">end</span>


    <span class="keyword">case</span> EDGE45
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+2,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+1,low_threshold);
        <span class="keyword">if</span> ~(Fout11) &amp;&amp; (Fout21)
            <span class="keyword">if</span> ((j+1) &lt; n*d+1 ) &amp;&amp; (i+1 &lt; m+1) &amp;&amp; (tempHyst(i+1,j+1) == 0)
                tempHyst(i+1,j+1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Fout31) || (Fout41)) &amp;&amp; ((Fout51) || (Fout61))
            <span class="keyword">if</span> ((j+1) &lt; n*d+1 ) &amp;&amp; (i+1 &lt; m+1 ) &amp;&amp; (tempHyst(i+1,j+1) == 0)

                tempHyst(i+1,j+1) = 5;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">return</span>;
    <span class="keyword">otherwise</span>
        <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [] = image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)
<span class="keyword">global</span> tempHyst EDGEX EDGEY EDGE45 EDGE135   n d



choice = tempHyst(i,j);

<span class="keyword">switch</span> choice
    <span class="keyword">case</span> EDGEY
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-2,low_threshold);
        <span class="keyword">if</span> ~(Bout11) &amp;&amp; (Bout21)
            <span class="keyword">if</span> ((i-1 &gt;= 1) &amp;&amp; (tempHyst(i,j-1) == 0))

                tempHyst(i,j-1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Bout31) || (Bout41)) &amp;&amp; ((Bout51) || (Bout61))
            <span class="keyword">if</span> ((i-1 &gt;= 1) &amp;&amp; (tempHyst(i,j-1) == 0))

                tempHyst(i,j-1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> EDGE135
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-1,low_threshold);
        <span class="keyword">if</span> ~(Bout11) &amp;&amp; (Bout21)
            <span class="keyword">if</span> ((j+1) &lt; n*d+1 ) &amp;&amp; (i-1 &gt;= 1) &amp;&amp; (tempHyst(i+1,j-1) == 0)

                tempHyst(i+1,j-1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Bout31) || (Bout41)) &amp;&amp; ((Bout51) || (Bout61))
            <span class="keyword">if</span> ((j+1) &lt; n*d+1) &amp;&amp; (i-1 &gt;= 1) &amp;&amp; (tempHyst(i+1,j-1) == 0)

                tempHyst(i+1,j-1) = 5;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> EDGEX
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-1,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+1,low_threshold);
        <span class="keyword">if</span> ~(Bout11) &amp;&amp; (Bout21)
            <span class="keyword">if</span> ((j+1 &lt; n*d+1 ) &amp;&amp; (tempHyst(i+1,j) == 0))

                tempHyst(i+1,j) = 5;

            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Bout31) || (Bout41)) &amp;&amp; ((Bout51) || (Bout61))
            <span class="keyword">if</span> ((j+1 &lt; n*d+1 ) &amp;&amp; (tempHyst(i+1,j) == 0))
                tempHyst(i+1,j) = 5;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> EDGE45
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-1,low_threshold);
        <span class="keyword">if</span> ~(Bout11) &amp;&amp; (Bout21)
            <span class="keyword">if</span> ((j-1) &gt;= 1 ) &amp;&amp; (i-1 &gt;= 1) &amp;&amp; (tempHyst(i-1,j-1) == 0)

                tempHyst(i-1,j-1) = 5;
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (~(Bout31) || (Bout41)) &amp;&amp; ((Bout51) || (Bout61))
            <span class="keyword">if</span> ((j-1) &gt;= 1 ) &amp;&amp; (i-1 &gt;= 1) &amp;&amp; (tempHyst(i-1,j-1) == 0)

                tempHyst(i-1,j-1) = 5;

            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">otherwise</span>
         <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

<span class="keyword">global</span> tempHyst  m n d

<span class="keyword">if</span> (i &lt;= 1)||(i &gt;= m)||(j &lt;= 1)||(j &gt;= n*d)
    out = 0;

    <span class="keyword">return</span>;
<span class="keyword">end</span>

<span class="keyword">if</span> ~(tempHyst(i,j)==0)
    out = 1;
    <span class="keyword">return</span>;
<span class="keyword">elseif</span> ~(image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold) == 0)
    tempHyst(i,j) = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold);
    image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold);
    out = 1;

    <span class="keyword">return</span>;
<span class="keyword">else</span>
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

<span class="keyword">global</span> tempHyst m n d

<span class="keyword">if</span> (i &lt;= 1)||(i &gt;= m)||(j &lt;= 1)||(j &gt;= n*d)
    out = 0;

    <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> ~(tempHyst(i,j)==0)
    out = 1;

    <span class="keyword">return</span>;
<span class="keyword">elseif</span> ~(image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold) == 0)
    tempHyst(i,j) = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold);
    image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold);

    out = 1;
    <span class="keyword">return</span>;
<span class="keyword">else</span>
    out = 0;

    <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold)
<span class="keyword">global</span> EDGEX EDGEY EDGE45 EDGE135 diag_scale
sx = abs(imgdetx(i,j));
sy = abs(imgdety(i,j));
s45 = int8(double(abs(imgdet45(i,j)))/diag_scale);
s135 = int8(double(abs(imgdet135(i,j)))/diag_scale);
out = 0;
big = sx;
orient_flag = EDGEX;

<span class="keyword">if</span> (sy &gt; big)
    big = sy;
    orient_flag = EDGEY;
<span class="keyword">end</span>
<span class="keyword">if</span> (s45 &gt; big)
    big = s45;
    orient_flag = EDGE45;
<span class="keyword">end</span>
<span class="keyword">if</span> (s135 &gt; big)
    big = s135;
    orient_flag = EDGE135;
<span class="keyword">end</span>

<span class="keyword">if</span> (big &gt; low_threshold)
    <span class="keyword">switch</span> orient_flag
        <span class="keyword">case</span> EDGEX
            out = image_zc_x_hys(i,j,imgdetx);
        <span class="keyword">case</span> EDGEY
            out = image_zc_y_hys(i,j,imgdety);
        <span class="keyword">case</span> EDGE45
            out = image_zc_45_hys(i,j,imgdet45);
        <span class="keyword">case</span> EDGE135
            out = image_zc_135_hys(i,j,imgdet135);
    <span class="keyword">end</span>
<span class="keyword">else</span>
   out = 0;
<span class="keyword">end</span>
<span class="keyword">end</span>



<span class="keyword">function</span> [out] = image_zc_x_hys(r,c,imgdetx)
<span class="keyword">global</span> EDGEX
a1 = image_locx_hys(c,r,imgdetx);
a2 = image_locx_hys(c+1,r,imgdetx);

    <span class="keyword">if</span> ~isequal((a1 &gt; 0),a2 &gt; 0)
        out = EDGEX;
    <span class="keyword">else</span>
        out = 0;
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [out] = image_zc_y_hys(r,c,imgdety)
<span class="keyword">global</span> EDGEY
a1 = image_locy_hys(c,r+1,imgdety);
a2 = image_locy_hys(c,r,imgdety);

    <span class="keyword">if</span> ~isequal(a1 &gt; 0,a2 &gt; 0)
        out = EDGEY;
    <span class="keyword">else</span>
        out = 0;
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> [out] = image_zc_45_hys(r,c,imgdet45)
<span class="keyword">global</span> EDGE45
a1 = image_loc45_hys(c-1,r+1,imgdet45);
a2 = image_loc45_hys(c,r,imgdet45);


<span class="keyword">if</span> ~isequal(a1 &gt; 0,a2 &gt; 0)
    out = EDGE45;
<span class="keyword">else</span>
    out = 0;
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_zc_135_hys(r,c,imgdet135)
<span class="keyword">global</span> EDGE135
a1 = image_loc135_hys(c+1,r+1,imgdet135);
a2 = image_loc135_hys(c,r,imgdet135);

<span class="keyword">if</span> ~isequal(a1&gt; 0,a2 &gt; 0)
    out = EDGE135;
<span class="keyword">else</span>
    out = 0;
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_locx_hys(c,r,imgdetx)
<span class="keyword">global</span> m n d


<span class="keyword">if</span> (r &lt; 2) || (r &gt; m - 2) || (c &lt; 2) || (c &gt; n*d-1)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdetx(r,c) - imgdetx(r,c-1);

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_locy_hys(c,r,imgdety)
<span class="keyword">global</span> m n d


<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-1) || (c &lt; 2) || (c &gt; n*d-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdety(r,c) - imgdety(r-1,c);
<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_loc45_hys(c,r,imgdet45)
<span class="keyword">global</span> m n d

<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-2) || (c &lt; 2) || (c &gt; n*d-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdet45(r,c) - imgdet45(r-1,c+1);

<span class="keyword">end</span>

<span class="keyword">function</span> [out] = image_loc135_hys(c,r,imgdet135)
<span class="keyword">global</span> m n d

<span class="keyword">if</span> (r &lt; 2) || (r &gt; m-2) || (c &lt; 2) || (c &gt; n*d-2)
    out = 0;
    <span class="keyword">return</span>;
<span class="keyword">end</span>
out = imgdet135(r,c) - imgdet135(r-1,c-1);
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
function [ out_img, TH_img, hTH_img ] = boiecox_ed_cvip( input_img, va, hys_th, thin, high_th, low_th )
% BOIECOX_ED_CVIP - Boiecox edge detection of an input image.
%
% Syntax :
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% [ out_img ] = boiecox_ed_cvip( input_img, va, hys_th, thin, high_th, low_th )
% 
% Description :
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% The function performs the Boiecox edge detection on an image. The Boiecox
% edge detection algorithm was developed by R.A. Boie and I.J. Cox in 1987. 
% The algorithm is similar to that of Canny's edge detection algorithm. It 
% is a multistep algorithm where the image is first blurred with a Gaussian 
% kernel and then a matched filter is applied to the image. The matched 
% filter is used to find and detect the edges in an image and localize them
% to subpixel accuracy. The image is then operated by a wiener filter which
% boosts the signal amplitude and reduces the noise that may be present in 
% the image. Matched filter is applied in an edge normal direction whereas 
% wiener filter is applied along the edge contour.
%
% Input Parameters Include:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% 
%             'input_img'     The Input Image. Can be Single band or Multi band.
%             
%                    'va'     Variance of the Gaussian blur Kernel.                              
%                             It decides the size of the Gaussian kernel used.
%                             Ranges from 0.5 to 10.          
%             
%                    
%                 'hys_th'    Hysteresis Threshold. It is either 0 or 1.
%                             '1' indicates Hysteresis thresholding.
%                             '0' indicates no hysteresis thresholding.
%                             Default value : 1.
%                     
%                   'thin'    Morphological thinning of output. It is either 0 or 1.
%                             '1' indicates thinning operation.
%                             '0' indicates no thinning operation.
%                             Default value : 1.
%                   
%               'high_th'     High Threshold value used in Hysteresis Thresholding.
%                             Ranges from 1 to 10. When Hysteresis threshold is not selected,
%                             used as a threshold value for ordinary thresholding.
%              
%                 'low_th'    Low Threshold value used in hysteresis thresholding.
%                             Ranges from 0 to 1.
%                      
% Example:          
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-                 
%                          input_img = imread('car.bmp');
%                          va = 1;
%                          hys_th = 1;
%                          thin = 1;
%                          high_th = 1;
%                          low_th = 0.2;
%                          output = boiecox_ed_cvip(input_img,va,hys_th,thin,high_th,low_th);
%                          figure; imshow(output);
% Reference
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH   
%  1. R.A. Boie, I.J. Cox, Two Dimensional Optimum Recognition Using Matched Filters and Wiener
%  Filters for Machine Vision, IEEE First International Conference on Computer Vision,
%  IEEE, pp.450-456, 1987.
 
% =========================================================================
%                     
%           Author:                 Akhila Karlapalem
%           Initial coding date:    11/22/2017
%           Updated by:             Julian Rene Cuellar Buritica
%           Latest update date:     01/20/2019
%           Credit:                 Scott Umbaugh 
%                                   CVIP Lab, SIUE
%           Copyright (C) 2016 Scott Umbaugh and SIUE
% 
% 
% =========================================================================  

% Revision History
%
 % Revision 1.2  01/20/2019  15:41:56  jucuell
 % intermadite variables for Thresholding image output anf hysteresis TH.
%
 % Revision 1.1  11/22/2017  15:21:14  akarlap
 % function creation, coding and initial testing
%

global EDGEX EDGEY EDGE45 EDGE135 diag_scale m n d

input_img = remap_cvip(input_img,[0 255]);
[m,n,d] = size(input_img);
diag_scale = 1.414;
EDGEX = 252;
EDGEY = 253;
EDGE45 = 254;
EDGE135 = 255;

if isempty(hys_th)
    hys_th = 1;
end
if isempty(thin)
    thin = 1;
end
%% create a gaussian filter mask
hlf = int8(sqrt(-log(0.05)*2*va*va));
sze = 2*hlf + 1;
sze = double(sze);

gau = zeros(sze,sze);


for i = 1:sze
    for j = 1:sze
        r = double(i);
        c = double(j);
        u1 = r - (sze + 1)/2;
        u2 = c - (sze + 1)/2;
        gau(i,j) = gaussboie(double(u1), va)* gaussboie(double(u2),va);
    end
end
gau = double(gau);


temp_img = input_img;
%% convovle gaussian filter with image
img_x = convn(temp_img,gau,'same');
%% Find determinants in four different directions
imgdetx = img_detx(img_x);
imgdety = img_dety(img_x);
imgdet135 = img_det135(img_x);
imgdet45 = img_det45(img_x);

TH_img = zeros(m,n,d);

sx = abs(imgdetx(:,:,:));
sy = abs(imgdety(:,:,:));
s45 = int8(double(abs(imgdet45(:,:,:))./diag_scale));
s135 = int8(double(abs(imgdet135(:,:,:))./diag_scale));

%% Apply Ordinary Thresholding   
    
    threshold = image_threshold(imgdetx(:,:,:));   
    
        thresholdValue = high_th*threshold;   
   
    for r = 1:m 
        for c = 1:n      
           
            big = sx(r,c,:);
            orient_flag = EDGEX;
            
            if (sy(r,c,:) > big)
                big = sy(r,c,:);
                orient_flag = EDGEY;
            end
            if (s45(r,c,:) > big)
                big = s45(r,c,:);
                orient_flag = EDGE45;
            end
            if (s135(r,c,:) > big)
                big = s135(r,c,:);
                orient_flag = EDGE135;
            end
           
           for b = 1:d
               if (big(b) > thresholdValue(b))
                switch orient_flag
                    case EDGEX
                        TH_img(r,c,b) = image_zc_x(r,c,imgdetx,b);
                        
                    case EDGEY
                        TH_img(r,c,b) = image_zc_y(r,c,imgdety,b);
                        
                    case EDGE45
                        TH_img(r,c,b) = image_zc_45(r,c,imgdet45,b);
                        
                    case EDGE135
                        TH_img(r,c,b) = image_zc_135(r,c,imgdet135,b);
                end
               end
           end
        end
    end        
    out_img = TH_img;    

%% Apply Hysteresis Thresholding
hTH_img = 0;
if isequal(hys_th,1)
    low_threshold = double(thresholdValue.*low_th);   
    hTH_img = image_hysteresis(imgdetx,imgdety,imgdet45,imgdet135,out_img,low_threshold);
    out_img = hTH_img;
end
%% Apply thinning 
if isequal(thin,1)
    out_img = image_thin(out_img);
end

end


function [ z ] = gaussboie( x,va )

x = double(x);
if isequal(va,0)
    z = double(zero(size(x)));
    return;
end
z1 = (-x.*x)/(2*va*va);
z2 = (va*sqrt(2*pi));
z = double(exp(double(z1))/z2);
end

function [imgdetx] = img_detx(img_x)
global m n d
imgdetx = zeros(m,n,d);

image2 = img_x;


% Middle Columns
j = 3:n-1;

        imgdetx(:,j,:) = image2(:,j+1,:) - image2(:,j-1,:);

end

function [imgdety] = img_dety(img_x)
global m n d

imgdety = zeros(m,n,d);

image2 = img_x;

% Middle Rows

i = 3:m-1;
   
        imgdety(i,:,:) = image2(i+1,:,:) - image2(i-1,:,:);


end

function [imgdet135] = img_det135(img_x)
global m n d
imgdet135 = zeros(m,n,d);

image2 = img_x;

j = 3:n-1;



% Diagonal
for i = 3:m-1

        imgdet135(i,j,:) = image2(i+1,j+1,:) - image2(i-1,j-1,:);

end



i = 3:m-1;

% Right Column

    imgdet135(i,n,:) = image2(i+1,n,:) - image2(i-1,n-1,:);


% Bottom Row Without Corner Pixels

    j = 3:n-1;
    imgdet135(m,j,:) = image2(m,j+1,:) - image2(m-1,j-1,:);


% Top Left Corner
imgdet135(1,1,:) = image2(2,2,:) - image2(1,1,:);

% Bottom Left Corner
imgdet135(m,1,:) = image2(m,2,:) - image2(m-1,1,:);

% Bottom Right Corner
imgdet135(m,n,:) = image2(m,n,:) - image2(m-1,n-1,:);

% Top Right Corner
imgdet135(1,n,:) = image2(2,n,:) - image2(1,n-1,:);

imgdet135(:,:,:) = imgdet135;


end

function [imgdet45] = img_det45(img_x)
global m n d
imgdet45 = zeros(m,n,d);

image2 = img_x;
    j = 3:n-1;
% Diagonal
for i = 3:m-1

        imgdet45(i,j,:) = image2(i+1,j-1,:) - image2(i-1,j+1,:);

end


    i = 3:m-1;

% Right Column

    imgdet45(i,n,:) = image2(i+1,n-1,:) - image2(i-1,n,:);


% Bottom Row without Corner Pixels

    j = 3:n-1;
    imgdet45(m,j,:) = image2(m,j-1,:) - image2(m-1,j+1,:);


% Top Left Corner
imgdet45(1,1,:) = image2(2,1,:) - image2(1,2,:);

% Bottom Left Corner
imgdet45(m,1,:) = image2(m,1,:) - image2(m-1,2,:);

% Bottom Right Corner
imgdet45(m,n,:) = image2(m,n-1,:) - image2(m-1,n,:);

% Top Right Corner
imgdet45(1,n,:) = image2(2,n-1,:) - image2(1,n,:);

imgdet45(:,:,:) = imgdet45;


end

function [threshold] = image_threshold(imagedetx)
global m n d
threshold = zeros(1,1,d);
for b = 1:d
a = imagedetx(:,:,b);
s = sum(a(:));
mad2 = s/numel(imagedetx);
mad1 = abs(imagedetx(:,:,b) - mad2);
mad = sum(mad1(:));
threshold(:,:,b) = int8(double((3*mad/m/n))/0.8);
end
end

function [outImage] = image_thin(out_img)
global m n d
for b = 1:d
    for j = 2:n-1
        for i = 2:m-1
            b01 = out_img(i-1,j,b) > 0;
            b12 = out_img(i,j+1,b) > 0;
            b21 = out_img(i+1,j,b) > 0;
            b10 = out_img(i,j-1,b) > 0;
            
            if ((b01 + b12 + b21 + b10) > 1)
                b00 = out_img(i-1,j-1,b) > 0;
                b02 = out_img(i-1,j+1,b) > 0;
                b20 = out_img(i+1,j-1,b) > 0;
                b22 = out_img(i+1,j+1,b) > 0;
                
                p1 = b00|b01;
                p2 = b02|b12;
                p3 = b22|b21;
                p4 = b20|b10;
                
                nlinks(1) = b01 & p2;
                nlinks(2) = b12 & p3;
                nlinks(3) = b21 & p4;
                nlinks(4) = b10 & p1;
                
                nlinks = sum(nlinks(:));
                
                npieces = p1 + p2 + p3 + p4;
                
                if ((npieces - nlinks) < 2)
                    out_img(i,j,b) = 0;
                end
            end
        end
    end
end

outImage = out_img;
end

function [out] = image_zc_x(r,c,imgdetx,b)
global EDGEX
a1 = image_locx(c,r,imgdetx,b);
a2 = image_locx(c+1,r,imgdetx,b);

    if ~isequal((a1 > 0),a2 > 0)
        out = EDGEX;
    else
        out = 0;
    end
end


function [out] = image_zc_y(r,c,imgdety,b)
global EDGEY
a1 = image_locy(c,r+1,imgdety,b);
a2 = image_locy(c,r,imgdety,b);

    if ~isequal(a1 > 0,a2 > 0)
        out = EDGEY;
    else
        out = 0;
    end
end


function [out] = image_zc_45(r,c,imgdet45,b)
global EDGE45
a1 = image_loc45(c-1,r+1,imgdet45,b);
a2 = image_loc45(c,r,imgdet45,b);


if ~isequal(a1 > 0,a2 > 0)
    out = EDGE45;
else
    out = 0;
end

end

function [out] = image_zc_135(r,c,imgdet135,b)
global EDGE135
a1 = image_loc135(c+1,r+1,imgdet135,b);
a2 = image_loc135(c,r,imgdet135,b);

if ~isequal(a1> 0,a2 > 0)
    out = EDGE135;
else
    out = 0;
end

end

function [out] = image_locx(c,r,imgdetx,b)
global m n 


if (r < 2) || (r > m - 2) || (c < 2) || (c > n-1)
    out = 0;
    return;
end
out = imgdetx(r,c,b) - imgdetx(r,c-1,b);

end

function [out] = image_locy(c,r,imgdety,b)
global m n 


if (r < 2) || (r > m-1) || (c < 2) || (c > n-2)
    out = 0;
    return;
end
out = imgdety(r,c,b) - imgdety(r-1,c,b);
end

function [out] = image_loc45(c,r,imgdet45,b)
global m n 

if (r < 2) || (r > m-2) || (c < 2) || (c > n-2)
    out = 0;
    return;
end
out = imgdet45(r,c,b) - imgdet45(r-1,c+1,b);

end

function [out] = image_loc135(c,r,imgdet135,b)
global m n 

if (r < 2) || (r > m-2) || (c < 2) || (c > n-2)
    out = 0;
    return;
end
out = imgdet135(r,c,b) - imgdet135(r-1,c-1,b);
end


function [out_img] = image_hysteresis(imgdetx,imgdety,imgdet45,imgdet135,out_img,low_threshold)

global tempHyst m n d
tempHyst = zeros(m,n,d);
tempHyst(2:m,2:n,1) = out_img(2:m,2:n,1);
if (d > 1)
    for f = 2:d
    tempHyst(2:m,2:n,f) = out_img(2:m,2:n,f);   
    end
end

[row,col] = find(tempHyst);
for i = 1:length(row)    
if (col(i) <= n )
    b = 1;
elseif (col(i)> n) && (col(i) <= n*2)
    b = 2;
else
    b = 3;
end    
    image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,col(i),row(i),low_threshold(b));
    image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,col(i),row(i),low_threshold(b));

end
out_img = tempHyst;
end

function [] = image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

global tempHyst EDGEX EDGEY EDGE45 EDGE135  m n d
choice = tempHyst(i,j);
switch choice
    case EDGEY
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+2,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+2,low_threshold);
        if ~(Fout11) && (Fout21)
            if ((i+1 < m+1 ) && (tempHyst(i-1,j+1) == 0))                
                tempHyst(i,j+1) = 5;                           
            end
        elseif (~(Fout31) || (Fout41)) && ((Fout51) || (Fout61))
            if ((i+1 < m+1 ) && (tempHyst(i-1,j+1) == 0))       
                
                tempHyst(i,j+1) = 5;              
           
            end
        end
        
    case EDGE135
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+1,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+2,low_threshold);
        if ~(Fout11) && (Fout21)
            if ((j-1) >= 1 ) && (i+1 < m+1 ) && (tempHyst(i-1,j+1) == 0)               
                tempHyst(i-1,j+1) = 5;           
            end
        elseif (~(Fout31) || (Fout41)) && ((Fout51) || (Fout61))
            if ((j-1) >= 1 ) && (i+1 < m+1 ) && (tempHyst(i-1,j+1) == 0)            
               
                tempHyst(i-1,j+1) = 5;
          
            end
        end
       
    case EDGEX
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i+1,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-1,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i+1,low_threshold);
        if ~(Fout11) && (Fout21)
            if ((j-1 >= 1) && (tempHyst(i-1,j) == 0))
               
                tempHyst(i-1,j) = 5;
           
            end
        elseif (~(Fout31) || (Fout41)) && ((Fout51) || (Fout61))
            if ((j-1 >= 1) && (tempHyst(i-1,j) == 0))              
                tempHyst(i-1,j) = 5;
          
            end
        end
        
        
    case EDGE45
        [Fout11] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Fout21] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+2,low_threshold);
        [Fout31] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i+1,low_threshold);
        [Fout41] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Fout51] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+2,low_threshold);
        [Fout61] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+1,low_threshold);
        if ~(Fout11) && (Fout21)
            if ((j+1) < n*d+1 ) && (i+1 < m+1) && (tempHyst(i+1,j+1) == 0)              
                tempHyst(i+1,j+1) = 5;
         
            end
        elseif (~(Fout31) || (Fout41)) && ((Fout51) || (Fout61))
            if ((j+1) < n*d+1 ) && (i+1 < m+1 ) && (tempHyst(i+1,j+1) == 0)
              
                tempHyst(i+1,j+1) = 5;
            end
        end
        return;      
    otherwise
        return;        
end
end


function [] = image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)
global tempHyst EDGEX EDGEY EDGE45 EDGE135   n d



choice = tempHyst(i,j);

switch choice
    case EDGEY
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-2,low_threshold);
        if ~(Bout11) && (Bout21)
            if ((i-1 >= 1) && (tempHyst(i,j-1) == 0))
              
                tempHyst(i,j-1) = 5;
        
            end
        elseif (~(Bout31) || (Bout41)) && ((Bout51) || (Bout61))
            if ((i-1 >= 1) && (tempHyst(i,j-1) == 0))
                
                tempHyst(i,j-1) = 5;
     
            end
        end
        
    case EDGE135
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-1,low_threshold);
        if ~(Bout11) && (Bout21)
            if ((j+1) < n*d+1 ) && (i-1 >= 1) && (tempHyst(i+1,j-1) == 0)
                
                tempHyst(i+1,j-1) = 5;
         
            end
        elseif (~(Bout31) || (Bout41)) && ((Bout51) || (Bout61))
            if ((j+1) < n*d+1) && (i-1 >= 1) && (tempHyst(i+1,j-1) == 0)
              
                tempHyst(i+1,j-1) = 5;        
            end
        end
        
    case EDGEX
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+1,i+1,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i-1,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j+2,i+1,low_threshold);
        if ~(Bout11) && (Bout21)
            if ((j+1 < n*d+1 ) && (tempHyst(i+1,j) == 0))
              
                tempHyst(i+1,j) = 5;
        
            end
        elseif (~(Bout31) || (Bout41)) && ((Bout51) || (Bout61))
            if ((j+1 < n*d+1 ) && (tempHyst(i+1,j) == 0))               
                tempHyst(i+1,j) = 5;      
            end
        end
        
    case EDGE45
        [Bout11] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-1,low_threshold);
        [Bout21] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-2,low_threshold);
        [Bout31] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i-1,low_threshold);
        [Bout41] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i,low_threshold);
        [Bout51] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-1,i-2,low_threshold);
        [Bout61] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j-2,i-1,low_threshold);
        if ~(Bout11) && (Bout21)
            if ((j-1) >= 1 ) && (i-1 >= 1) && (tempHyst(i-1,j-1) == 0)
                
                tempHyst(i-1,j-1) = 5;   
            end
        elseif (~(Bout31) || (Bout41)) && ((Bout51) || (Bout61))
            if ((j-1) >= 1 ) && (i-1 >= 1) && (tempHyst(i-1,j-1) == 0)
              
                tempHyst(i-1,j-1) = 5;
       
            end
        end       
    
    otherwise
         return;
end
end

function [out] = Fcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

global tempHyst  m n d

if (i <= 1)||(i >= m)||(j <= 1)||(j >= n*d)
    out = 0;
   
    return;
end

if ~(tempHyst(i,j)==0)
    out = 1;    
    return;
elseif ~(image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold) == 0)
    tempHyst(i,j) = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold);
    image_neighbor_fwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold);
    out = 1;
    
    return;
else
    out = 0;    
    return;
end
end

function [out] = Bcontour(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold)

global tempHyst m n d

if (i <= 1)||(i >= m)||(j <= 1)||(j >= n*d)
    out = 0;
    
    return;
end
if ~(tempHyst(i,j)==0)
    out = 1;
   
    return;
elseif ~(image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold) == 0)
    tempHyst(i,j) = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold);
    image_neighbor_bwd(imgdetx,imgdety,imgdet45,imgdet135,j,i,low_threshold);
   
    out = 1;
    return;
else
    out = 0;
    
    return;
end
end

function [out] = image_edge_map_lo(imgdetx,imgdety,imgdet45,imgdet135,i,j,low_threshold)
global EDGEX EDGEY EDGE45 EDGE135 diag_scale
sx = abs(imgdetx(i,j));
sy = abs(imgdety(i,j));
s45 = int8(double(abs(imgdet45(i,j)))/diag_scale);
s135 = int8(double(abs(imgdet135(i,j)))/diag_scale);
out = 0;
big = sx;
orient_flag = EDGEX;

if (sy > big)
    big = sy;
    orient_flag = EDGEY;
end
if (s45 > big)
    big = s45;
    orient_flag = EDGE45;
end
if (s135 > big)
    big = s135;
    orient_flag = EDGE135;
end

if (big > low_threshold)
    switch orient_flag
        case EDGEX
            out = image_zc_x_hys(i,j,imgdetx);
        case EDGEY
            out = image_zc_y_hys(i,j,imgdety);
        case EDGE45
            out = image_zc_45_hys(i,j,imgdet45);
        case EDGE135
            out = image_zc_135_hys(i,j,imgdet135);
    end
else
   out = 0; 
end
end



function [out] = image_zc_x_hys(r,c,imgdetx)
global EDGEX
a1 = image_locx_hys(c,r,imgdetx);
a2 = image_locx_hys(c+1,r,imgdetx);

    if ~isequal((a1 > 0),a2 > 0)
        out = EDGEX;
    else
        out = 0;
    end
end


function [out] = image_zc_y_hys(r,c,imgdety)
global EDGEY
a1 = image_locy_hys(c,r+1,imgdety);
a2 = image_locy_hys(c,r,imgdety);

    if ~isequal(a1 > 0,a2 > 0)
        out = EDGEY;
    else
        out = 0;
    end
end


function [out] = image_zc_45_hys(r,c,imgdet45)
global EDGE45
a1 = image_loc45_hys(c-1,r+1,imgdet45);
a2 = image_loc45_hys(c,r,imgdet45);


if ~isequal(a1 > 0,a2 > 0)
    out = EDGE45;
else
    out = 0;
end

end

function [out] = image_zc_135_hys(r,c,imgdet135)
global EDGE135
a1 = image_loc135_hys(c+1,r+1,imgdet135);
a2 = image_loc135_hys(c,r,imgdet135);

if ~isequal(a1> 0,a2 > 0)
    out = EDGE135;
else
    out = 0;
end

end

function [out] = image_locx_hys(c,r,imgdetx)
global m n d


if (r < 2) || (r > m - 2) || (c < 2) || (c > n*d-1)
    out = 0;
    return;
end
out = imgdetx(r,c) - imgdetx(r,c-1);

end

function [out] = image_locy_hys(c,r,imgdety)
global m n d


if (r < 2) || (r > m-1) || (c < 2) || (c > n*d-2)
    out = 0;
    return;
end
out = imgdety(r,c) - imgdety(r-1,c);
end

function [out] = image_loc45_hys(c,r,imgdet45)
global m n d

if (r < 2) || (r > m-2) || (c < 2) || (c > n*d-2)
    out = 0;
    return;
end
out = imgdet45(r,c) - imgdet45(r-1,c+1);

end

function [out] = image_loc135_hys(c,r,imgdet135)
global m n d

if (r < 2) || (r > m-2) || (c < 2) || (c > n*d-2)
    out = 0;
    return;
end
out = imgdet135(r,c) - imgdet135(r-1,c-1);
end
##### SOURCE END #####
--></body></html>